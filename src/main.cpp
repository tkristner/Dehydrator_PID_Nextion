/*
By: Thomas KRISTNER
Date: October 2020

This code is for a DIY PID driven dehydrator, based on a SSR (Solid state relay) to control heaters and fans, a Nextion display is used as a display/control interface.

The dehydrator code is designed for a two zones splited dehydrator, Top and Bottom, the need was to be able to use it at half capacity.

Physically it implies having 2x heaters, 2x fans (4 in my case) the Nextion control allow to start the bottom zone if needed.

To get a "synced" PWM signal for 50Hz AC 230v I use "Fast PWM to ICR1".

I've choosed to put the bottom heater/fans in parrallel to the top ones with an Y cable that connect to the SSR output that is generating the AC PWM signal, and installed a mechanical relay to on/off bottom zone.
Please be careful to choose a SSR sized to suppport the amount of current drained by heaters.

A BIG Thanks to :
- https://github.com/br3ttb and https://github.com/jackw01
- https://github.com/Seithan/
- Nick Gammon for the Timerx cheatsheets

Don't hesitate to make pull request.

Enjoy !
*/

#include <Arduino.h>
#include <Wire.h>
#include <PID_v1.h>
#include <SHTSensor.h>
#include <EasyNextionLibrary.h>
#include <pidautotuner.h>
#include <SimpleTimer.h>

SimpleTimer timer;

SHTSensor sht;  // this is our precision temperature sensor, it is placed just after the fans to measure the heated air temperature entering the dehydrator room where we put something to dry.

// PID limits should reflect actual configuration, in our case -255 to 0 for cooling and 0 to 255 for heating.
#define PID_MIN -255
#define PID_MAX  255

const uint8_t bottom_heater = 5;  // (connected in serial behind the SSR relay named "heaters", allow for half use of the dehydrator).
const uint8_t bottom_fans = 6;    // (connected in serial behind the SSR relay named "fans", allow for half use of the dehydrator).
const uint8_t leds = 7;
const uint8_t heaters = 9;      // equal Timer1(A) output = "OC1A".
const uint8_t fans = 10;        // equal Timer1(B) output = "OC1B".

double Setpoint, Input, Output;
double Kp= 2003.51;  //
double Ki= 397.68;  // Kp, Ki, Kd founded with the pidautotuner using Ziegler-Nichols/relay method or by hand with the same method.
double Kd= 7182.60;  //

//PID myPID(&Input, &Output, &Setpoint, Kp, Ki, Kd, P_ON_M, DIRECT);  // define an object of the PID class. Input will be the temp sensor value, Output the PID computation result, Setpoint the desired temp, P_ON_M is "proportinal on measurement" method implemented by Brett Beauregard in his PID library.
PID myPID(&Input, &Output, &Setpoint, Kp, Ki, Kd, DIRECT);  // define an object of the PID class. Input will be the temp sensor value, Output the PID computation result, Setpoint the desired temp, P_ON_M is "proportinal on measurement" method implemented by Brett Beauregard in his PID library.

double PIDSAMPLETIME_MS=400; // We'll define PWM frequency to 2.5Hz so there we do the same, useless to sample at a higher freq.

int pwm_dc_heaters=0; // PWM duty cycle for heaters.
int pwm_dc_fans=0;    // PWM duty cycle for fans.

EasyNex myNex(Serial);  // EasyNextion Easynex object with Serial attached.


double get_air_temp(){                      // measure incoming air flow temperature
  double air_temp = 0;                      
  if (sht.readSample()) {                   // call sht.readsample which reads a temperature and humidity sample from the sensor
    for (uint8_t i=0; i<4; i++ ){           // smoothing values
      air_temp += sht.getTemperature();     // to get the temp value from the last sample
    }
    air_temp = air_temp/4;
  }
  return air_temp;
}

double get_air_humidity(){                  // measure incoming air flow humidity
  double air_humidity = 0;
  if (sht.readSample()) {                   // call sht.readsample which reads a temperature and humidity sample from the sensor
    for (uint8_t i=0; i<4; i++ ){           // smoothing values
      air_humidity += sht.getHumidity();    // to get the humidity value from the last sample
    }
    air_humidity = air_humidity/4;
  }
  return air_humidity;
}

void PWM_output(){      // PWM for PID+ (heat) and PID- (cool).
  if (Output >= 0){
    int OCR1A_pwm = map(Output, 0, 255, 0, 6250);
    OCR1A = OCR1A_pwm;  // if PID Output >= 0  (generated by myPID.compute) we should heat up the incoming air flow, we assign the Output value generated by "myPID.compute" to OCR1A
    OCR1B = 1875;       // and we keep 30% (6250*0.3) of PWM duty cycle for fans, because we need to maintain a minimal air flow.
  } else {
    int OCR1B_pwm = map(-Output, 0, 255, 1875, 6250);
    OCR1A = 0;          // in this case (Output < 0) we need to cool the incoming air so we stop the heater(s).
    OCR1B = OCR1B_pwm;   // and we map the positive value (negative negative) of Output generated by "myPID.compute" over the minimal threshold of 30% fan speed.
  }
  myNex.writeStr("t2.txt","Temp = "+String(Input)+"\\rOCR1A heater= "+String(OCR1A)+"\\rOCR1B fans= "+String(OCR1B)+"\\r"); // just to debug values on the Nextion screen.
}

void PID_compute(){
  if ( (Setpoint > 0) && (Setpoint <= 55) ){  // We check the consistency of the Setpoint.
    Input = get_air_temp();                   // we probe the temp with the sht35 sensor.
    myPID.Compute();                          // we start the PID computation.
    PWM_output();                             // since PID computation is done we apply the Output result to PWM.
  }
}

void autotuner(){
  PIDAutotuner tuner = PIDAutotuner();
  tuner.setTargetInputValue(Setpoint);
  tuner.setLoopInterval(400000);
  tuner.setOutputRange(PID_MIN, PID_MAX);
  tuner.setZNMode(PIDAutotuner::ZNModeLessOvershoot);
  tuner.startTuningLoop(micros());
  long microseconds;
  while (!tuner.isFinished()) {     // This loop must run at the same speed as the PID control loop being tuned
    microseconds = micros();
    double input = get_air_temp();
    double autotuner_output = tuner.tunePID(input, microseconds);     // Call tunePID() with the input value and current time in microseconds
    //
    if (autotuner_output >= 0){
      int OCR1A_pwm = map(autotuner_output, 0, 255, 0, 6250);
      OCR1A = OCR1A_pwm;      // if PID Output >= 0  (generated by myPID.compute) we should heat up the incoming air flow, we assign the Output value generated by "myPID.compute" to OCR1A
      OCR1B = 1875;           // and we keep 30% (6250*0.3) of PWM duty cycle for fans, because we need to maintain a minimal air flow.
    } else {
      int OCR1B_pwm = map(-autotuner_output, 0, 255, 1875, 6250);
      OCR1A = 0;              // in this case (Output < 0) we need to cool the incoming air so we stop the heater(s).
      OCR1B = OCR1B_pwm;      // and we map the positive value (negative negative) of Output generated by "myPID.compute" over the minimal threshold of 30% fan speed.
    }
    myNex.writeStr("t2.txt","Autotune Sp= "+String(Setpoint)+"\\rTemp= "+String(input)+"\\r"+String(OCR1A)+"  "+String(OCR1B));     // just to debug values on Nextion screen.
    while (micros() - microseconds < 400000) delayMicroseconds(1);      // This loop must run at the same speed as the PID control loop being tuned
  }
  //
  OCR1A = 0;
  OCR1B = 0;
  //
  Kp = tuner.getKp();       // get the Kp autotuner computed value.
  Ki = tuner.getKi()/2;     // get the KI autotuner computed value. I'd to divide by two the computed Ki value to get better results.
  Kd = tuner.getKd();       // get the Kd autotuner computed value.
  //
  myPID.SetTunings(Kp, Ki, Kd);
  //myNex.writeStr("t2.txt","Kp = "+String(Kp)+"\\rKi= "+String(Ki)+"\\rKd= "+String(Kd)+"\\r");  // just to show PID values during 15s on the Nextion display.
  //delay(15000);
}

void trigger1(){                                              // Trigger1 is the trigger called when the "NextionListen" catch a "23 02 54 01".
  digitalWrite(bottom_heater, !digitalRead(bottom_heater));   // we change the heater and fan relay state by putting the opposite state.
  digitalWrite(bottom_fans, !digitalRead(bottom_fans));       // same for fans
}

void trigger2(){                                              // Trigger2 is the trigger called when the "NextionListen" catch a "23 02 54 02".
  digitalWrite(leds, !digitalRead(leds));                     // We change the led state by putting the opposite state.
}

void trigger3(){                                              // Trigger3 is the trigger called when the "NextionListen" catch a "23 02 54 03".
  autotuner();                                                // We launch the pidautotuner computation.
}

void nextion_button_background(){             // Here we ensure that the correct background image on Nextion display is the correct one regarding the relay state.
  if(digitalRead(bottom_heater) == HIGH){     // If the relay is "on" for the bottom heater we change the "crop image" picc and picc2 background of the b2 button with the image where all button are "on".
    myNex.writeNum("b2.picc", 1);             // I choose to not let Nextion managing button background, just want to avoid shifting state/issue, I prefer read the state of a relay and put the correct background.
    myNex.writeNum("b2.picc2", 1);
  }
  else if(digitalRead(bottom_heater) == LOW){ // same thing there
    myNex.writeNum("b2.picc", 0);
    myNex.writeNum("b2.picc2", 0);
  }
  if(digitalRead(leds) == HIGH){              // same thing there
    myNex.writeNum("b3.picc", 1);
    myNex.writeNum("b3.picc2", 1);
  }
  else if(digitalRead(leds) == LOW){          // same thing there
    myNex.writeNum("b3.picc", 0);
    myNex.writeNum("b3.picc2", 0);
  }
}

void nextion_show_temp(){             // We want to show the measured temperature on the Nextion display.
  int temp = get_air_temp()*10;       // As Nextion only accept integer, we multiply by ten the "double" returned by get_air_temp and put the result in a "integer".
  myNex.writeNum("x0.val", temp);     // We write the value not to a "Xfloat", this allow to reconstruct a float on the Nextion display.
}

void nextion_read_set_temp(){                 // We want to retrieve the desired temperature configured on the Nextion display.
  Setpoint = myNex.readNumber("n1.val");      // The value of Nextion object "n1" (number 1) is assigned to the PID Setpoint.
}

void NextionListen(){
  myNex.NextionListen();
}

void setup() {
  cli();      // stop interrupts.
  TCCR1A = 0;     // reset register bits.
  TCCR1B = 0;
  TCNT1  = 0;
  // set register bits.
  TCCR1A = _BV(COM1A1) | _BV(COM1B1) | _BV(WGM11);            // Output A (D9) and output B (D10) set to clear "10". WGM11 set to "1"
  TCCR1B = _BV(CS12) | _BV(CS10) | _BV(WGM12) | _BV(WGM13);   // Timer1 (atmega328p clock) 16MHz / (prescaler)1024 = 15.625 KHz. CS12 and CS10 set to "1" (101 for prescaler 1024). WGM12 and 13 set to "1" ( 1110 for timer mode "Fast PWM to ICR1")
  ICR1 = 6250;                                                // 15625 / 6250 = 2.5Hz (used to generate the PWM signal frequency, this will allow inclusion of 20 cycles of AC 50Hz).
  OCR1A = 0;                                                  // Set the Output Compare Register 1 A (output A D9), compare A limit, to zero, this equal to a PWM duty cycle of 0%. For example if you want 10% dc you need to enter 625.
  OCR1B = 0;                                                  // Same for Digital port D10.
  // allow interrupts.
  sei();
  // set pinmode output for relays.
  pinMode (bottom_heater, OUTPUT);
  pinMode (bottom_fans, OUTPUT);
  pinMode (leds, OUTPUT);
  pinMode (heaters, OUTPUT);
  pinMode (fans, OUTPUT);
  // ensure bottom zone and leds are off
  digitalWrite(bottom_heater,LOW);
  digitalWrite(bottom_fans,LOW);
  digitalWrite(leds,LOW);
  //
  Wire.begin();
  myNex.begin(115200);      // the nextion sketch is also configured for 115200.
  delay(1000);      // just a dirty delay :)
  //
  while (!sht.init())  {      // waiting for the sht35 sensor to init.
  }
  //
  sht.setAccuracy(SHTSensor::SHT_ACCURACY_MEDIUM);// Set the accuracy mode to MEDIUM (LOW and HIGH are available)
  // configuration  of myPID
  myPID.SetMode(AUTOMATIC);
  myPID.SetSampleTime(PIDSAMPLETIME_MS);
  myPID.SetOutputLimits(PID_MIN, PID_MAX);
  delay(1000);      // just a dirty delay :)
  // configure all interval of execution for timer, this is milliseconds.
  timer.setInterval( 10, NextionListen );
  timer.setInterval( 1000, nextion_read_set_temp );
  timer.setInterval( 50, nextion_button_background );
  timer.setInterval( 1000, nextion_show_temp );
  timer.setInterval( 5, PID_compute );
}


void loop() {                       // we loop over the simpleTimer timer.
  timer.run();
}
